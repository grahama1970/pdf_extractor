# Code Execution Validation Module
#
# This module handles validation of code generated by LLMs, extracting code from text
# responses and executing it in a controlled environment to verify correctness.
#
# ## Third-Party Packages:
# - httpx: https://www.python-httpx.org/ (v0.24.1)
# - loguru: https://github.com/Delgan/loguru (v0.7.0)
#
# ## Sample Input:
# Python code snippet to validate:
# ```python
# def factorial(n):
#     if n == 0 or n == 1:
#         return 1
#     else:
#         return n * factorial(n-1)
#
# print(factorial(5))
# ```
#
# ## Expected Output:
# {
#   "is_valid": true,
#   "execution_result": {
#     "exit_code": 0,
#     "execution_time": 0.05,
#     "stdout": "120\n",
#     "stderr": "",
#     "language": "python",
#     "timed_out": false,
#     "memory_exceeded": false
#   }
# }

import re
import json
import httpx
from typing import Dict, Tuple, Any
from loguru import logger

class CodeExecutorClient:
    """Client for the code execution service."""
    
    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url
    
    def execute_code(
        self, 
        code: str, 
        language: str = "python", 
        timeout: int = 60, 
        max_memory_mb: int = 2048
    ) -> Dict[str, Any]:
        """
        Execute code in a controlled environment.
        
        Args:
            code: The code to execute
            language: Programming language (default: python)
            timeout: Execution timeout in seconds
            max_memory_mb: Memory limit in MB
            
        Returns:
            Dictionary with execution results
        """
        try:
            # Actual API call to the real service
            with httpx.Client(timeout=timeout + 5) as client:
                response = client.post(
                    f"{self.base_url}/execute",
                    json={
                        "code": code,
                        "language": language,
                        "timeout": timeout,
                        "max_memory_mb": max_memory_mb
                    }
                )
                
                if response.status_code == 200:
                    return response.json()
                else:
                    return {
                        "exit_code": 1,
                        "execution_time": 0,
                        "stdout": "",
                        "stderr": f"Service error: {response.status_code} - {response.text}",
                        "language": language,
                        "timed_out": False,
                        "memory_exceeded": False
                    }
        except Exception as e:
            return {
                "exit_code": 1,
                "execution_time": 0,
                "stdout": "",
                "stderr": f"Error calling code execution service: {str(e)}",
                "language": language,
                "timed_out": False,
                "memory_exceeded": False
            }

def extract_code_from_text(text: str) -> str:
    """
    Extracts code blocks from text, handling markdown code blocks.
    
    Args:
        text: Text potentially containing code blocks
        
    Returns:
        Extracted code or empty string if no code blocks found
    """
    # Try to extract code from markdown code blocks
    code_blocks = re.findall(r"```(?:python)?\n(.*?)```", text, re.DOTALL)
    if code_blocks:
        return code_blocks[0].strip()
    
    # If no markdown blocks found, try to find code patterns
    # (like functions, classes, etc. that might indicate code)
    lines = text.split('\n')
    code_lines = []
    in_code_block = False
    
    for line in lines:
        # Common Python code patterns
        if re.match(r'^\s*def\s+\w+\s*\(', line) or \
           re.match(r'^\s*class\s+\w+', line) or \
           re.match(r'^\s*import\s+', line) or \
           re.match(r'^\s*from\s+\w+\s+import', line) or \
           re.match(r'^\s*for\s+\w+\s+in\s+', line) or \
           re.match(r'^\s*if\s+.*:', line) or \
           re.match(r'^\s*while\s+.*:', line) or \
           in_code_block:
            code_lines.append(line)
            in_code_block = True
    
    if code_lines:
        return '\n'.join(code_lines)
    
    return ""

def validate_code_execution(code: str, task_id: str, call_id: int, language: str = "python", 
                            timeout: int = 60, max_memory_mb: int = 2048) -> Tuple[bool, Dict[str, Any]]:
    """
    Validates if code executes correctly.
    
    Args:
        code: The code to execute
        task_id: Task identifier for logging
        call_id: Call identifier for logging
        language: Programming language (default: python)
        timeout: Execution timeout in seconds
        max_memory_mb: Memory limit in MB
        
    Returns:
        (is_valid, results): Validation result and execution details
    """
    logger.info(f"[Task {task_id}] Executing code for validation: {language}, timeout={timeout}s")
    
    # Initialize code executor client
    client = CodeExecutorClient(base_url="http://localhost:8000")
    
    # Execute the code
    execution_result = client.execute_code(
        code=code,
        language=language,
        timeout=timeout,
        max_memory_mb=max_memory_mb
    )
    
    # Code executes successfully if exit code is 0
    is_valid = execution_result["exit_code"] == 0
    
    if is_valid:
        logger.info(f"[Task {task_id}] ✅ Code execution validation PASSED for call {call_id}:")
        logger.info(f"[Task {task_id}]    Exit code: {execution_result['exit_code']}")
        logger.info(f"[Task {task_id}]    Execution time: {execution_result['execution_time']:.2f}s")
        logger.info(f"[Task {task_id}]    Output: {execution_result['stdout'][:100]}")
    else:
        logger.error(f"[Task {task_id}] ❌ Code execution validation FAILED for call {call_id}:")
        logger.error(f"[Task {task_id}]    Exit code: {execution_result['exit_code']}")
        logger.error(f"[Task {task_id}]    Output: {execution_result['stdout'][:100]}")
        logger.error(f"[Task {task_id}]    Errors: {execution_result['stderr'][:100]}")
    
    return is_valid, execution_result

if __name__ == "__main__":
    import sys
    
    # Test data - define the factorial code as a raw string to avoid any escape issues
    factorial_code = r"""
def factorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * factorial(n-1)

print(factorial(5))
"""
    
    # Test data - define the buggy code as a raw string to avoid any escape issues
    buggy_code = r"""
def factorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        # Bug: missing return statement
        n * factorial(n-1)

print(factorial(5))
"""
    
    # Test code extraction from text with embedded code block - use raw string
    text_with_code = r"""
Here's a factorial function in Python:

```python
def factorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * factorial(n-1)
```

You can use it to calculate 5! = 120.
"""
    
    # Define expected results
    EXPECTED_FACTORIAL_OUTPUT = "120\n"
    EXPECTED_EXTRACTION_PRESENT = True
    EXPECTED_VALID_CODE_PASS = True
    EXPECTED_INVALID_CODE_FAIL = True # We expect the validation to return False for invalid code

    # Run validation tests
    print("Testing code execution validation against the REAL service at http://localhost:8000")
    
    # Test with valid code
    valid_result, valid_details = validate_code_execution(
        code=factorial_code,
        task_id="test_valid_main", # Use distinct task_id
        call_id=1
    )
    actual_factorial_output = valid_details.get("stdout", "")
    
    # Test with buggy code
    invalid_result, invalid_details = validate_code_execution(
        code=buggy_code,
        task_id="test_invalid_main", # Use distinct task_id
        call_id=2
    )
    
    # Test code extraction
    extracted_code = extract_code_from_text(text_with_code)
    extraction_success = "factorial" in extracted_code
    
    # --- Detailed Validation ---
    validation_passed = True
    validation_failures = {}

    # 1. Validate valid code execution result
    if valid_result != EXPECTED_VALID_CODE_PASS:
        validation_passed = False
        validation_failures["valid_code_execution"] = {
            "expected": EXPECTED_VALID_CODE_PASS,
            "actual": valid_result
        }
        
    # 2. Validate valid code output content
    if actual_factorial_output != EXPECTED_FACTORIAL_OUTPUT:
         validation_passed = False
         validation_failures["valid_code_output"] = {
             "expected": repr(EXPECTED_FACTORIAL_OUTPUT),
             "actual": repr(actual_factorial_output)
         }

    # 3. Validate invalid code detection (should return False)
    if invalid_result != (not EXPECTED_INVALID_CODE_FAIL): # invalid_result should be False
        validation_passed = False
        validation_failures["invalid_code_detection"] = {
            "expected": not EXPECTED_INVALID_CODE_FAIL,
            "actual": invalid_result
        }

    # 4. Validate code extraction
    if extraction_success != EXPECTED_EXTRACTION_PRESENT:
        validation_passed = False
        validation_failures["code_extraction"] = {
            "expected": EXPECTED_EXTRACTION_PRESENT,
            "actual": extraction_success
        }

    # --- Report validation status ---
    if validation_passed:
        print("✅ VALIDATION COMPLETE - All results match expected values")
        sys.exit(0)
    else:
        print("❌ VALIDATION FAILED - Results don't match expected values")
        print(f"FAILURE DETAILS:")
        for field, details in validation_failures.items():
            print(f"  - {field}: Expected: {details['expected']}, Got: {details['actual']}")
        print(f"Total errors: {len(validation_failures)} checks failed")
        # Optionally print full details for debugging
        # print("\nFull details (valid code):", valid_details)
        # print("Full details (invalid code):", invalid_details)
        sys.exit(1)