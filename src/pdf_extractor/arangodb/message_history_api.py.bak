# src/pdf_extractor/arangodb/message_history_api.py
"""
API for storing and retrieving conversation messages in ArangoDB.

This module provides functions to store, retrieve, and manage 
conversation messages between users and agents.
"""
import sys
import uuid
import json
from datetime import datetime, timezone, timedelta
from typing import Dict, Any, List, Optional, Union, Tuple
from loguru import logger

from arango.database import StandardDatabase
from arango.exceptions import (
    ArangoClientError,
    ArangoServerError,
    DocumentInsertError,
    DocumentGetError
)

from pdf_extractor.arangodb.arango_setup import connect_arango, ensure_database
from pdf_extractor.arangodb.message_history_setup import initialize_message_history
from pdf_extractor.arangodb.message_history_config import (
    MESSAGE_COLLECTION_NAME,
    MESSAGE_EDGE_COLLECTION_NAME,
    MESSAGE_GRAPH_NAME,
    MESSAGE_TYPE_USER,
    MESSAGE_TYPE_AGENT,
    MESSAGE_TYPE_SYSTEM,
    MESSAGE_MAX_LENGTH,
    MESSAGE_MIN_LENGTH,
    REQUIRED_MESSAGE_FIELDS,
    RELATIONSHIP_TYPE_NEXT
)

def validate_message(message: Dict[str, Any]) -> Tuple[bool, Optional[str]]:
    """
    Validate a message before storing it.
    
    Args:
        message: The message to validate
        
    Returns:
        Tuple[bool, Optional[str]]: (is_valid, error_message)
    """
    # Check required fields
    for field in REQUIRED_MESSAGE_FIELDS:
        if field not in message:
            return False, f"Missing required field: {field}"
    
    # Validate message type
    valid_types = [MESSAGE_TYPE_USER, MESSAGE_TYPE_AGENT, MESSAGE_TYPE_SYSTEM]
    if message["message_type"] not in valid_types:
        return False, f"Invalid message type: {message['message_type']}"
    
    # Validate content length
    content_length = len(message["content"])
    if content_length < MESSAGE_MIN_LENGTH:
        return False, f"Message content too short: {content_length} < {MESSAGE_MIN_LENGTH}"
    
    if content_length > MESSAGE_MAX_LENGTH:
        return False, f"Message content too long: {content_length} > {MESSAGE_MAX_LENGTH}"
    
    # Validate conversation ID (should be a UUID)
    try:
        uuid.UUID(message["conversation_id"])
    except ValueError:
        return False, f"Invalid conversation ID format, expected UUID"
    
    # Validate timestamp (should be ISO format)
    try:
        if isinstance(message["timestamp"], str):
            datetime.fromisoformat(message["timestamp"].replace('Z', '+00:00'))
    except (ValueError, TypeError):
        return False, f"Invalid timestamp format, expected ISO 8601"
    
    return True, None

def prepare_message(
    conversation_id: str,
    message_type: str,
    content: str,
    metadata: Optional[Dict[str, Any]] = None,
    timestamp: Optional[str] = None
) -> Dict[str, Any]:
    """
    Prepare a message for storing.
    
    Args:
        conversation_id: Unique identifier for the conversation
        message_type: Type of message (USER, AGENT, SYSTEM)
        content: Message content
        metadata: Optional metadata for the message
        timestamp: Optional timestamp (ISO format). If None, current time is used.
        
    Returns:
        Dict[str, Any]: Prepared message object
    """
    # Generate timestamp if not provided
    if not timestamp:
        timestamp = datetime.now(timezone.utc).isoformat()
    
    # Generate a unique message ID
    message_id = str(uuid.uuid4())
    
    # Prepare the message object
    message = {
        "_key": message_id,
        "conversation_id": conversation_id,
        "message_type": message_type,
        "content": content,
        "timestamp": timestamp,
        "metadata": metadata or {}
    }
    
    return message

def add_message(
    db: StandardDatabase,
    conversation_id: str,
    message_type: str,
    content: str,
    metadata: Optional[Dict[str, Any]] = None,
    timestamp: Optional[str] = None,
    previous_message_key: Optional[str] = None
) -> Optional[Dict[str, Any]]:
    """
    Add a message to the message history collection.
    
    Args:
        db: ArangoDB database handle
        conversation_id: Unique identifier for the conversation
        message_type: Type of message (USER, AGENT, SYSTEM)
        content: Message content
        metadata: Optional metadata for the message
        timestamp: Optional timestamp (ISO format). If None, current time is used.
        previous_message_key: Optional key of the previous message to link to
        
    Returns:
        Optional[Dict[str, Any]]: The stored message if successful, None otherwise
    """
    try:
        # Prepare the message
        message = prepare_message(
            conversation_id=conversation_id,
            message_type=message_type,
            content=content,
            metadata=metadata,
            timestamp=timestamp
        )
        
        # Validate the message
        valid, error = validate_message(message)
        if not valid:
            logger.error(f"Invalid message: {error}")
            return None
        
        # Insert the message into the collection
        collection = db.collection(MESSAGE_COLLECTION_NAME)
        result = collection.insert(message, return_new=True)
        
        # If we have a previous message, create a relationship
        if previous_message_key:
            try:
                edge_collection = db.collection(MESSAGE_EDGE_COLLECTION_NAME)
                edge = {
                    "_from": f"{MESSAGE_COLLECTION_NAME}/{previous_message_key}",
                    "_to": f"{MESSAGE_COLLECTION_NAME}/{message['_key']}",
                    "type": RELATIONSHIP_TYPE_NEXT,
                    "timestamp": message["timestamp"]
                }
                edge_collection.insert(edge)
                logger.debug(f"Created relationship between messages: {previous_message_key} -> {message['_key']}")
            except Exception as e:
                logger.warning(f"Failed to create relationship between messages: {e}")
        
        logger.info(f"Added message to conversation: {conversation_id}")
        return result["new"]
    
    except (DocumentInsertError, ArangoServerError, ArangoClientError) as e:
        logger.error(f"Failed to add message: {e}")
        return None

def get_conversation_messages(
    db: StandardDatabase,
    conversation_id: str,
    limit: int = 100,
    offset: int = 0,
    sort_order: str = "asc"
) -> List[Dict[str, Any]]:
    """
    Get messages for a specific conversation.
    
    Args:
        db: ArangoDB database handle
        conversation_id: Unique identifier for the conversation
        limit: Maximum number of messages to return
        offset: Number of messages to skip
        sort_order: Sort order by timestamp ("asc" or "desc")
        
    Returns:
        List[Dict[str, Any]]: List of messages
    """
    try:
        # Validate sort order
        if sort_order not in ["asc", "desc"]:
            sort_order = "asc"
        
        sort_direction = "ASC" if sort_order == "asc" else "DESC"
        
        # Query messages for the conversation
        aql = f"""
        FOR msg IN {MESSAGE_COLLECTION_NAME}
        FILTER msg.conversation_id == @conversation_id
        SORT msg.timestamp {sort_direction}
        LIMIT @offset, @limit
        RETURN msg
        """
        
        bind_vars = {
            "conversation_id": conversation_id,
            "offset": offset,
            "limit": limit
        }
        
        cursor = db.aql.execute(aql, bind_vars=bind_vars)
        messages = list(cursor)
        
        logger.info(f"Retrieved {len(messages)} messages for conversation: {conversation_id}")
        return messages
    
    except Exception as e:
        logger.error(f"Failed to get conversation messages: {e}")
        return []

def get_message_by_key(db: StandardDatabase, message_key: str) -> Optional[Dict[str, Any]]:
    """
    Get a message by its key.
    
    Args:
        db: ArangoDB database handle
        message_key: Key of the message to retrieve
        
    Returns:
        Optional[Dict[str, Any]]: The message if found, None otherwise
    """
    try:
        collection = db.collection(MESSAGE_COLLECTION_NAME)
        message = collection.get(message_key)
        return message
    
    except (DocumentGetError, ArangoServerError, ArangoClientError) as e:
        logger.error(f"Failed to get message by key: {e}")
        return None

def search_messages(
    db: StandardDatabase,
    query_text: str,
    conversation_id: Optional[str] = None,
    message_type: Optional[str] = None,
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    limit: int = 50
) -> List[Dict[str, Any]]:
    """
    Search for messages based on various criteria.
    
    Args:
        db: ArangoDB database handle
        query_text: Text to search for in message content
        conversation_id: Optional conversation ID to filter by
        message_type: Optional message type to filter by
        start_date: Optional start date (ISO format) to filter by
        end_date: Optional end date (ISO format) to filter by
        limit: Maximum number of results to return
        
    Returns:
        List[Dict[str, Any]]: List of matching messages
    """
    try:
        # Build filter conditions
        filter_conditions = []
        bind_vars = {
            "query_text": query_text,
            "limit": limit
        }
        
        if conversation_id:
            filter_conditions.append("msg.conversation_id == @conversation_id")
            bind_vars["conversation_id"] = conversation_id
        
        if message_type:
            filter_conditions.append("msg.message_type == @message_type")
            bind_vars["message_type"] = message_type
        
        if start_date:
            filter_conditions.append("msg.timestamp >= @start_date")
            bind_vars["start_date"] = start_date
        
        if end_date:
            filter_conditions.append("msg.timestamp <= @end_date")
            bind_vars["end_date"] = end_date
        
        # Build the filter clause
        filter_clause = " AND ".join(filter_conditions)
        if filter_clause:
            filter_clause = f"FILTER {filter_clause} AND"
        else:
            filter_clause = "FILTER"
        
        # Query messages matching criteria
        aql = f"""
        FOR msg IN {MESSAGE_COLLECTION_NAME}
        {filter_clause} CONTAINS(LOWER(msg.content), LOWER(@query_text))
        SORT msg.timestamp DESC
        LIMIT @limit
        RETURN msg
        """
        
        cursor = db.aql.execute(aql, bind_vars=bind_vars)
        messages = list(cursor)
        
        logger.info(f"Found {len(messages)} messages matching search criteria")
        return messages
    
    except Exception as e:
        logger.error(f"Failed to search messages: {e}")
        return []

def delete_conversation(db: StandardDatabase, conversation_id: str) -> bool:
    """
    Delete all messages in a conversation.
    
    Args:
        db: ArangoDB database handle
        conversation_id: ID of the conversation to delete
        
    Returns:
        bool: True if successful, False otherwise
    """
    try:
        # First, get all message keys for the conversation
        aql_keys = f"""
        FOR msg IN {MESSAGE_COLLECTION_NAME}
        FILTER msg.conversation_id == @conversation_id
        RETURN msg._key
        """
        
        cursor_keys = db.aql.execute(aql_keys, bind_vars={"conversation_id": conversation_id})
        message_keys = list(cursor_keys)
        
        if not message_keys:
            logger.info(f"No messages found for conversation: {conversation_id}")
            return True
        
        # Delete all message relationships
        edge_collection = db.collection(MESSAGE_EDGE_COLLECTION_NAME)
        message_collection = db.collection(MESSAGE_COLLECTION_NAME)
        
        for key in message_keys:
            # Find and delete outgoing edges
            aql_out = f"""
            FOR edge IN {MESSAGE_EDGE_COLLECTION_NAME}
            FILTER edge._from == @from
            RETURN edge._key
            """
            
            cursor_out = db.aql.execute(
                aql_out, 
                bind_vars={"from": f"{MESSAGE_COLLECTION_NAME}/{key}"}
            )
            
            for edge_key in cursor_out:
                edge_collection.delete(edge_key)
            
            # Find and delete incoming edges
            aql_in = f"""
            FOR edge IN {MESSAGE_EDGE_COLLECTION_NAME}
            FILTER edge._to == @to
            RETURN edge._key
            """
            
            cursor_in = db.aql.execute(
                aql_in, 
                bind_vars={"to": f"{MESSAGE_COLLECTION_NAME}/{key}"}
            )
            
            for edge_key in cursor_in:
                edge_collection.delete(edge_key)
            
            # Delete the message
            message_collection.delete(key)
        
        logger.info(f"Deleted {len(message_keys)} messages for conversation: {conversation_id}")
        return True
    
    except Exception as e:
        logger.error(f"Failed to delete conversation: {e}")
        return False

def get_recent_conversations(
    db: StandardDatabase,
    limit: int = 10,
    offset: int = 0
) -> List[Dict[str, Any]]:
    """
    Get a list of recent conversations with summary information.
    
    Args:
        db: ArangoDB database handle
        limit: Maximum number of conversations to return
        offset: Number of conversations to skip
        
    Returns:
        List[Dict[str, Any]]: List of conversation summaries
    """
    try:
        # Query to get recent conversations with message counts
        aql = f"""
        FOR msg IN {MESSAGE_COLLECTION_NAME}
        COLLECT conversation_id = msg.conversation_id 
        AGGREGATE 
            message_count = COUNT(),
            first_timestamp = MIN(msg.timestamp),
            last_timestamp = MAX(msg.timestamp),
            user_messages = COUNT(msg.message_type == "{MESSAGE_TYPE_USER}"),
            agent_messages = COUNT(msg.message_type == "{MESSAGE_TYPE_AGENT}")
        SORT last_timestamp DESC
        LIMIT @offset, @limit
        RETURN {{
            "conversation_id": conversation_id,
            "message_count": message_count,
            "first_timestamp": first_timestamp,
            "last_timestamp": last_timestamp,
            "user_messages": user_messages,
            "agent_messages": agent_messages
        }}
        """
        
        bind_vars = {
            "offset": offset,
            "limit": limit
        }
        
        cursor = db.aql.execute(aql, bind_vars=bind_vars)
        conversations = list(cursor)
        
        logger.info(f"Retrieved {len(conversations)} recent conversations")
        return conversations
    
    except Exception as e:
        logger.error(f"Failed to get recent conversations: {e}")
        return []

if __name__ == "__main__":
    # Setup logging
    logger.remove()
    logger.add(sys.stderr, level="INFO")
    
    # Connect to ArangoDB and ensure database exists
    client = connect_arango()
    if not client:
        print("❌ Failed to connect to ArangoDB")
        sys.exit(1)
    
    db = ensure_database(client)
    if not db:
        print("❌ Failed to ensure database exists")
        sys.exit(1)
    
    # Initialize message history collections if needed
    initialize_message_history(db)
    
    # Validate with some test operations
    test_conversation_id = str(uuid.uuid4())
    
    # Test adding a user message
    user_message = add_message(
        db=db,
        conversation_id=test_conversation_id,
        message_type=MESSAGE_TYPE_USER,
        content="Hello, this is a test message from the user.",
        metadata={"user_id": "test_user", "tags": ["test"]}
    )
    
    if not user_message:
        print("❌ Failed to add user message")
        sys.exit(1)
    
    # Test adding an agent message
    agent_message = add_message(
        db=db,
        conversation_id=test_conversation_id,
        message_type=MESSAGE_TYPE_AGENT,
        content="Hello! I'm the agent responding to your test message.",
        metadata={"agent_id": "test_agent", "tags": ["test"]},
        previous_message_key=user_message["_key"]
    )
    
    if not agent_message:
        print("❌ Failed to add agent message")
        sys.exit(1)
    
    # Test retrieving conversation messages
    messages = get_conversation_messages(db, test_conversation_id)
    if len(messages) != 2:
        print(f"❌ Expected 2 messages, got {len(messages)}")
        sys.exit(1)
    
    # Clean up test data
    if not delete_conversation(db, test_conversation_id):
        print("❌ Failed to clean up test conversation")
        sys.exit(1)
    
    print("✅ Message history API validation passed")
    sys.exit(0)
